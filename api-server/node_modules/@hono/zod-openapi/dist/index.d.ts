import * as openapi3_ts_oas31 from 'openapi3-ts/oas31';
import * as openapi3_ts_oas30 from 'openapi3-ts/oas30';
import { RouteConfig, ZodMediaTypeObject, OpenAPIRegistry, ZodRequestBody, ZodContentObject, ResponseConfig } from '@asteasolutions/zod-to-openapi';
import { OpenAPIObjectConfig } from '@asteasolutions/zod-to-openapi/dist/v3.0/openapi-generator';
import { Env, Context, TypedResponse, Input, Handler, Schema, Hono, ToSchema } from 'hono';
import { MergeSchemaPath, MergePath } from 'hono/types';
import { RemoveBlankRecord } from 'hono/utils/types';
import { ZodError, AnyZodObject, z, ZodSchema, ZodType } from 'zod';
export { z } from 'zod';

type RequestTypes = {
    body?: ZodRequestBody;
    params?: AnyZodObject;
    query?: AnyZodObject;
    cookies?: AnyZodObject;
    headers?: AnyZodObject | ZodType<unknown>[];
};
type IsJson<T> = T extends string ? T extends `application/json${infer _Rest}` ? 'json' : never : never;
type IsForm<T> = T extends string ? T extends `multipart/form-data${infer _Rest}` | `application/x-www-form-urlencoded${infer _Rest}` ? 'form' : never : never;
type RequestPart<R extends RouteConfig, Part extends string> = Part extends keyof R['request'] ? R['request'][Part] : {};
type InputTypeBase<R extends RouteConfig, Part extends string, Type extends string> = R['request'] extends RequestTypes ? RequestPart<R, Part> extends AnyZodObject ? {
    in: {
        [K in Type]: z.input<RequestPart<R, Part>>;
    };
    out: {
        [K in Type]: z.output<RequestPart<R, Part>>;
    };
} : {} : {};
type InputTypeJson<R extends RouteConfig> = R['request'] extends RequestTypes ? R['request']['body'] extends ZodRequestBody ? R['request']['body']['content'] extends ZodContentObject ? IsJson<keyof R['request']['body']['content']> extends never ? {} : R['request']['body']['content'][keyof R['request']['body']['content']]['schema'] extends ZodSchema<any> ? {
    in: {
        json: z.input<R['request']['body']['content'][keyof R['request']['body']['content']]['schema']>;
    };
    out: {
        json: z.output<R['request']['body']['content'][keyof R['request']['body']['content']]['schema']>;
    };
} : {} : {} : {} : {};
type InputTypeForm<R extends RouteConfig> = R['request'] extends RequestTypes ? R['request']['body'] extends ZodRequestBody ? R['request']['body']['content'] extends ZodContentObject ? IsForm<keyof R['request']['body']['content']> extends never ? {} : R['request']['body']['content'][keyof R['request']['body']['content']]['schema'] extends ZodSchema<any> ? {
    in: {
        form: z.input<R['request']['body']['content'][keyof R['request']['body']['content']]['schema']>;
    };
    out: {
        form: z.output<R['request']['body']['content'][keyof R['request']['body']['content']]['schema']>;
    };
} : {} : {} : {} : {};
type InputTypeParam<R extends RouteConfig> = InputTypeBase<R, 'params', 'param'>;
type InputTypeQuery<R extends RouteConfig> = InputTypeBase<R, 'query', 'query'>;
type InputTypeHeader<R extends RouteConfig> = InputTypeBase<R, 'headers', 'header'>;
type InputTypeCookie<R extends RouteConfig> = InputTypeBase<R, 'cookies', 'cookie'>;
type OutputType<R extends RouteConfig> = R['responses'] extends Record<infer _, infer C> ? C extends ResponseConfig ? C['content'] extends ZodContentObject ? IsJson<keyof C['content']> extends never ? {} : C['content'][keyof C['content']]['schema'] extends ZodSchema ? z.infer<C['content'][keyof C['content']]['schema']> : {} : {} : {} : {};
type Hook<T, E extends Env, P extends string, O> = (result: {
    success: true;
    data: T;
} | {
    success: false;
    error: ZodError;
}, c: Context<E, P>) => TypedResponse<O> | Promise<TypedResponse<T>> | Response | Promise<Response> | void;
type ConvertPathType<T extends string> = T extends `${infer Start}/{${infer Param}}${infer Rest}` ? `${Start}/:${Param}${ConvertPathType<Rest>}` : T;
type HandlerTypedResponse<O> = TypedResponse<O> | Promise<TypedResponse<O>>;
type HandlerAllResponse<O> = Response | Promise<Response> | TypedResponse<O> | Promise<TypedResponse<O>>;
type OpenAPIHonoOptions<E extends Env> = {
    defaultHook?: Hook<any, E, any, any>;
};
type HonoInit<E extends Env> = ConstructorParameters<typeof Hono>[0] & OpenAPIHonoOptions<E>;
type RouteHandler<R extends RouteConfig, E extends Env = Env, I extends Input = InputTypeParam<R> & InputTypeQuery<R> & InputTypeHeader<R> & InputTypeCookie<R> & InputTypeForm<R> & InputTypeJson<R>, P extends string = ConvertPathType<R['path']>> = Handler<E, P, I, R extends {
    responses: {
        [statusCode: string]: {
            content: {
                [mediaType: string]: ZodMediaTypeObject;
            };
        };
    };
} ? HandlerTypedResponse<OutputType<R>> : HandlerAllResponse<OutputType<R>>>;
type RouteHook<R extends RouteConfig, E extends Env = Env, I extends Input = InputTypeParam<R> & InputTypeQuery<R> & InputTypeHeader<R> & InputTypeCookie<R> & InputTypeForm<R> & InputTypeJson<R>, P extends string = ConvertPathType<R['path']>> = Hook<I, E, P, OutputType<R>>;
type OpenAPIObjectConfigure<E extends Env, P extends string> = OpenAPIObjectConfig | ((context: Context<E, P>) => OpenAPIObjectConfig);
declare class OpenAPIHono<E extends Env = Env, S extends Schema = {}, BasePath extends string = '/'> extends Hono<E, S, BasePath> {
    openAPIRegistry: OpenAPIRegistry;
    defaultHook?: OpenAPIHonoOptions<E>['defaultHook'];
    constructor(init?: HonoInit<E>);
    openapi: <R extends RouteConfig, I extends Input = InputTypeBase<R, "params", "param"> & InputTypeBase<R, "query", "query"> & InputTypeBase<R, "headers", "header"> & InputTypeBase<R, "cookies", "cookie"> & InputTypeForm<R> & InputTypeJson<R>, P extends string = ConvertPathType<R["path"]>>(route: R, handler: Handler<E, P, I, R extends {
        responses: {
            [statusCode: string]: {
                content: {
                    [mediaType: string]: ZodMediaTypeObject;
                };
            };
        };
    } ? HandlerTypedResponse<OutputType<R>> : HandlerAllResponse<OutputType<R>>>, hook?: Hook<I, E, P, OutputType<R>> | undefined) => OpenAPIHono<E, S & ToSchema<R["method"], P, I["in"], OutputType<R>>, BasePath>;
    getOpenAPIDocument: (config: OpenAPIObjectConfig) => openapi3_ts_oas30.OpenAPIObject;
    getOpenAPI31Document: (config: OpenAPIObjectConfig) => openapi3_ts_oas31.OpenAPIObject;
    doc: <P extends string>(path: P, configure: OpenAPIObjectConfigure<E, P>) => OpenAPIHono<E, S & ToSchema<"get", P, {}, {}>, BasePath>;
    doc31: <P extends string>(path: P, configure: OpenAPIObjectConfigure<E, P>) => OpenAPIHono<E, S & ToSchema<"get", P, {}, {}>, BasePath>;
    route<SubPath extends string, SubEnv extends Env, SubSchema extends Schema, SubBasePath extends string>(path: SubPath, app: Hono<SubEnv, SubSchema, SubBasePath>): OpenAPIHono<E, MergeSchemaPath<SubSchema, MergePath<BasePath, SubPath>> & S, BasePath>;
    route<SubPath extends string>(path: SubPath): Hono<E, RemoveBlankRecord<S>, BasePath>;
    basePath<SubPath extends string>(path: SubPath): OpenAPIHono<E, S, MergePath<BasePath, SubPath>>;
}
type RoutingPath<P extends string> = P extends `${infer Head}/{${infer Param}}${infer Tail}` ? `${Head}/:${Param}${RoutingPath<Tail>}` : P;
declare const createRoute: <P extends string, R extends Omit<RouteConfig, "path"> & {
    path: P;
}>(routeConfig: R) => R & {
    getRoutingPath(): RoutingPath<R["path"]>;
};

export { type Hook, OpenAPIHono, type OpenAPIHonoOptions, type OpenAPIObjectConfigure, type RouteHandler, type RouteHook, createRoute };
